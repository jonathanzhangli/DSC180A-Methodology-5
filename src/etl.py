# -*- coding: utf-8 -*-
"""EDA2_Jon.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zod-ur6vhtwRUHBH1veoGMb3xOv5aNql
"""

import pandas as pd
import numpy as np
import scipy.sparse as sparse
import networkx as nx
import matplotlib.pyplot as plt
from itertools import islice

"""Graph Visualization of the dataset"""

def show_graph(dataset_name):
    # Create graph instance
    graph = nx.DiGraph()

    # Open dataset
    with open(dataset_name) as f:
        lines = f.readlines()

        for line in lines[6:]:
            node_pairs = [float(node) for node in line.split()]
            graph.add_edge(node_pairs[0], node_pairs[1])
    
    # Plotting graph
    ax = plt.gca()
    ax.margins(0.08)
    plt.axis("off")
    plt.tight_layout()
    plt.draw()

    nx.draw_networkx(graph)

    plt.show()

# show_graph('S-cerevisiae.txt')

"""Building Adjacency Matrix and Lists"""

def get_data(dataset):
    # Load data and drop unneeded column
    data = pd.read_csv(dataset, header = 5, delimiter = ' ').drop(['Sign'], axis=1)

    # Adjust column names
    data = data.rename(columns = {'#': 'FromNodeId', 'FromNodeId': 'ToNodeId', 'ToNodeId': 'Weight', 'Weight': 'redundant'})
    return data

data = get_data('S-cerevisiae.txt')

# Function to build Adjacency Matrix given a dataframe
def create_adj_matrix(data):
    adj_matrix = pd.crosstab(data['FromNodeId'], data['ToNodeId'])

    # Square the matrix for faster computations down the line
    idx = adj_matrix.index.union(adj_matrix.columns)
    adj_matrix = adj_matrix.reindex(index=idx, columns=idx, fill_value=0).values

    return adj_matrix

adj_matrix = create_adj_matrix(data)
# adj_matrix

# Function to convert an Adjacency Matrix to an Adjacency List
def create_adj_list(adj_matrix):
    adj_dict = {}
    
    for i in range(len(adj_matrix)): # Run through all From-Nodes
        adj_dict[i] = []
        for j in range(len(adj_matrix[i])): # Run through all To-Nodes
            if adj_matrix[i][j] == 1:   # Checking to see matches in to To-Nodes
                adj_dict[i].append(j)
            
    return adj_dict

# Two Adjacency lists are created:

# 1. List of edges pointing to a certain Node (From -> To)
adj_list_away = create_adj_list(adj_matrix) 
# 2. List of edges pointing to a certain Node (To -> From)
adj_list_toward = create_adj_list(adj_matrix)

"""Counting the degree of each node. The degree of a node represents how many edges it is associated with."""

# Function to count the degrees of each node in our adjacency list
def count_degrees(adj_list):
    degree_dict = {i: len(adj_list_away[i]) for i in adj_list_away}
    return degree_dict

degree_counts = count_degrees(adj_list_away)
# degree_counts

# Function to plot degree frequencies using historgram
def plot_degrees(degree_counts):
    plt.hist(degree_counts.values())
    plt.title('Frequency vs Number Edges')
    plt.xlabel('Number of Edges')
    plt.ylabel('Frequency')
    plt.show()

# plot_degrees(degree_counts)

"""Counting Motifs
All Motifs Types can be found via [this aricle](https://cs.stanford.edu/people/jure/pubs/higher-order-science.pdf)
"""

def count_M1(adj_list_away, adj_list_toward):

    vertices = []
    
    for vertex1 in adj_list_away: # Checks all starting vertices
        for vertex2 in adj_list_away[vertex1]: # Find all nodes connected (vertex 2 from vertex 1)
            for vertex3 in adj_list_away[vertex2]: # Access all possible nodes (vertex 3 from vertex 2)
                
                if ((vertex1 in adj_list_away[vertex3]) & (vertex1 not in adj_list_toward[vertex3])
                    & (vertex3 not in adj_list_toward[vertex2]) & (vertex2 not in adj_list_toward[vertex1])):
                    
                    vertices.append([vertex1, vertex2, vertex3])
                    
    triangles = set(tuple(sorted(l)) for l in vertices) # Get rid of duplicate permutations of the same triangle
    
    return len(triangles)

def count_M2(adj_list_away, adj_list_toward):

    vertices = []
    
    for vertex1 in adj_list_away: # Checks all starting vertices
        for vertex2 in adj_list_away[vertex1]: # Find all nodes connected (vertex 2 from vertex 1)
            for vertex3 in adj_list_away[vertex2]: # Find all nodes connected (vertex 2 from vertex 1)
                
                if ((vertex1 in adj_list_away[vertex3]) & (vertex1 not in adj_list_toward[vertex3])
                    & (vertex3 not in adj_list_toward[vertex2]) & (vertex2 in adj_list_toward[vertex1])):
                    
                    vertices.append([vertex1, vertex2, vertex3])
                    
    triangles = set(tuple(sorted(l)) for l in vertices) # Get rid of duplicate permutations of the same triangle
    
    return len(triangles)

def count_M3(adj_list_away, adj_list_toward):

    vertices = []
    
    for vertex1 in adj_list_away: # Checks all starting vertices
        for vertex2 in adj_list_away[vertex1]: # Find all nodes connected (vertex 2 from vertex 1)
            for vertex3 in adj_list_away[vertex2]: # Find all nodes connected (vertex 2 from vertex 1)
                
                if ((vertex1 in adj_list_away[vertex3]) & (vertex1 not in adj_list_toward[vertex3])
                    & (vertex3 in adj_list_toward[vertex2]) & (vertex2 in adj_list_toward[vertex1])):
                    
                    vertices.append([vertex1, vertex2, vertex3])
                    
    triangles = set(tuple(sorted(l)) for l in vertices) # Get rid of duplicate permutations of the same triangle
    
    return len(triangles)

def count_M4(adj_list_away, adj_list_toward):

    vertices = []
    
    for vertex1 in adj_list_away: # Checks all starting vertices
        for vertex2 in adj_list_away[vertex1]: # Find all nodes connected (vertex 2 from vertex 1)
            for vertex3 in adj_list_away[vertex2]: # Find all nodes connected (vertex 2 from vertex 1)
                
                if ((vertex1 in adj_list_away[vertex3]) & (vertex1 in adj_list_toward[vertex3])
                    & (vertex3 in adj_list_toward[vertex2]) & (vertex2 in adj_list_toward[vertex1])
                    & (vertex1 != vertex2) & (vertex1 != vertex3) & (vertex2 != vertex3)):
                    
                    vertices.append([vertex1, vertex2, vertex3])
                    
    triangles = set(tuple(sorted(l)) for l in vertices) # Get rid of duplicate permutations of the same triangle
    
    return len(triangles)

def count_M5(adj_list_away, adj_list_toward):
    
    vertices = []
    
    for parent in adj_list_away: # Checks all parent nodes
        for child1 in adj_list_away[parent]: # Checks first child node
            for child2 in adj_list_away[parent]: # Checks second child node
                
                if ((child2 in adj_list_away[child1]) & (child2 not in adj_list_toward[child1])
                    & (child1 not in adj_list_toward[parent]) & (child2 not in adj_list_toward[parent])):
                    vertices.append([parent, child1, child2])
                    
    triangles = set(tuple(sorted(l)) for l in vertices) # Get rid of duplicate permutations of the same triangle

    return len(triangles)

def count_M6(adj_list_away, adj_list_toward):
    
    vertices = []
    
    for parent in adj_list_away: # Checks all parent nodes
        for child1 in adj_list_away[parent]: # Checks first child node
            for child2 in adj_list_away[parent]: # Checks second child node
                
                if ((child2 in adj_list_away[child1]) & (child2 in adj_list_toward[child1])
                    & (child1 not in adj_list_toward[parent]) & (child2 not in adj_list_toward[parent])):
                    vertices.append([parent, child1, child2])
                    
    triangles = set(tuple(sorted(l)) for l in vertices) # Get rid of duplicate permutations of the same triangle
    
    return len(triangles)

def count_M7(adj_list_away, adj_list_toward):
    
    vertices = []
    
    for parent1 in adj_list_away: # Checks all parent nodes
        for parent2 in adj_list_away: # Checks second parent nodes
            for child in adj_list_away[parent1]: # Checks child node
                
                if ((child in adj_list_away[parent2]) & (parent1 in adj_list_away[parent2])
                    & (parent2 in adj_list_away[parent1]) & (child not in adj_list_toward[parent1])
                    & (child not in adj_list_toward[parent2])):
                    
                    vertices.append([parent1, parent2, child])
                    
    triangles = set(tuple(sorted(l)) for l in vertices) # Get rid of duplicate permutations of the same triangle
    
    return len(triangles)

def count_M8(adj_list_away, adj_list_toward):
    
    vertices = []
    
    for parent in adj_list_away: # Checks all parent nodes
        for child1 in adj_list_away[parent]: # Checks first child node
            for child2 in adj_list_away[parent]: # Checks second child node
                
                if ((child2 not in adj_list_away[child1]) & (child2 not in adj_list_toward[child1])
                    & (child1 not in adj_list_toward[parent]) & (child2 not in adj_list_toward[parent])
                    & (child1 != child2)):
                    
                    vertices.append([parent, child1, child2])
                    
    triangles = set(tuple(sorted(l)) for l in vertices) # Get rid of duplicate permutations of the same triangle
    
    return len(triangles)

def count_M9(adj_list_away, adj_list_toward):
    
    vertices = []
    
    for vertex1 in adj_list_away: # Checks all vertices
        for vertex2 in adj_list_away[vertex1]: # Access all possible nodes (vertex 2 from vertex 1)
            for vertex3 in adj_list_away[vertex2]: # Access all possible nodes (vertex 3 from vertex 2)
                
                if ((vertex1 not in adj_list_away[vertex3]) & (vertex1 not in adj_list_toward[vertex3])
                    & (vertex3 not in adj_list_toward[vertex2]) & (vertex2 not in adj_list_toward[vertex1])
                    & (vertex1 != vertex3)):
                    
                    vertices.append([vertex1, vertex2, vertex3])
                    
    triangles = set(tuple(sorted(l)) for l in vertices) # Get rid of duplicate permutations of the same triangle
    
    return len(triangles)

def count_M10(adj_list_away, adj_list_toward):
    
    vertices = []
    
    for parent1 in adj_list_away: # Checks all parent nodes
        for parent2 in adj_list_away: # Checks second parent nodes
            for child in adj_list_away[parent1]: # Checks child node
                
                if ((child in adj_list_away[parent2]) & (parent1 not in adj_list_away[parent2])
                    & (parent2 not in adj_list_away[parent1]) & (child not in adj_list_toward[parent1])
                    & (child not in adj_list_toward[parent2]) & (parent1 != parent2)):
                    
                    vertices.append([parent1, parent2, child])
                    
    triangles = set(tuple(sorted(l)) for l in vertices) # Get rid of duplicate permutations of the same triangle
    
    return len(triangles)

def count_M11(adj_list_away, adj_list_toward):
    
    vertices = []
    
    for parent in adj_list_away: # Checks all parent nodes
        for child1 in adj_list_away[parent]: # Checks first child node
            for child2 in adj_list_away[parent]: # Checks second child node
                
                if ((child2 not in adj_list_away[child1]) & (child2 not in adj_list_toward[child1])
                    & (child1 in adj_list_toward[parent]) & (child2 not in adj_list_toward[parent])
                    & (child1 != child2)):
                    
                    vertices.append([parent, child1, child2])
                    
    triangles = set(tuple(sorted(l)) for l in vertices) # Get rid of duplicate permutations of the same triangle
    
    return len(triangles)

def count_M12(adj_list_away, adj_list_toward):
    
    vertices = []
    
    for vertex1 in adj_list_away: # Checks all vertices
        for vertex2 in adj_list_away[vertex1]: # Access all possible nodes (vertex 2 from vertex 1)
            for vertex3 in adj_list_away[vertex2]: # Access all possible nodes (vertex 3 from vertex 2)
                
                if ((vertex1 not in adj_list_away[vertex3]) & (vertex1 not in adj_list_toward[vertex3])
                    & (vertex3 in adj_list_toward[vertex2]) & (vertex2 not in adj_list_toward[vertex1])
                    & (vertex1 != vertex3)):
                    
                    vertices.append([vertex1, vertex2, vertex3])
                    
    triangles = set(tuple(sorted(l)) for l in vertices) # Get rid of duplicate permutations of the same triangle
    
    return len(triangles)

def count_M13(adj_list_away, adj_list_toward):
    
    vertices = []
    
    for parent in adj_list_away: # Checks all parent nodes
        for child1 in adj_list_away[parent]: # Checks first child node
            for child2 in adj_list_away[parent]: # Checks second child node
                
                if ((child2 not in adj_list_away[child1]) & (child2 not in adj_list_toward[child1])
                    & (child1 in adj_list_toward[parent]) & (child2 in adj_list_toward[parent])
                    & (child1 != child2)):
                    
                    vertices.append([parent, child1, child2])
                    
    triangles = set(tuple(sorted(l)) for l in vertices) # Get rid of duplicate permutations of the same triangle
    
    return len(triangles)

def get_all_counts(adj_list_away, adj_list_toward):
    counts = {}

    counts['Motif 1'] = count_M1(adj_list_away, adj_list_toward)
    counts['Motif 2'] = count_M2(adj_list_away, adj_list_toward)
    counts['Motif 3'] = count_M3(adj_list_away, adj_list_toward)
    counts['Motif 4'] = count_M4(adj_list_away, adj_list_toward)
    counts['Motif 5'] = count_M5(adj_list_away, adj_list_toward)
    counts['Motif 6'] = count_M6(adj_list_away, adj_list_toward)
    counts['Motif 7'] = count_M7(adj_list_away, adj_list_toward)
    counts['Motif 8'] = count_M8(adj_list_away, adj_list_toward)
    counts['Motif 9'] = count_M9(adj_list_away, adj_list_toward)
    counts['Motif 10'] = count_M10(adj_list_away, adj_list_toward)
    counts['Motif 11'] = count_M11(adj_list_away, adj_list_toward)
    counts['Motif 12'] = count_M12(adj_list_away, adj_list_toward)
    counts['Motif 13'] = count_M13(adj_list_away, adj_list_toward)

    return counts

# get_all_counts(adj_list_away, adj_list_toward)

